/* 
    Quadrotor Engine Set (of 4 engines)
    Created by jamesfe
    
    02JUL2014 - Created

*/

#include<iostream>
#include<cmath>

#include "qEngineSet.hpp"

using namespace std;

    qEngineSet::qEngineSet() {
    numEngines = 4;
    spinTestMS = 2000;
}

int qEngineSet::setupEngines() {
    int GPIOSet = gpioInitialise();
    if(GPIOSet==PI_INIT_FAILED) {
        cout << "PIGPIO Initialization Failed." << endl;
        return(-1);
    }
    
    // perform spin test
    // this is dangerous!! we need to warn the user.
    for(int i = 0; i < 4; i++) {
        quadEngines[i].stop();
    }
    cout << "DANGER!!!" << endl;
    cout << "About to perform the spin test; connect power supply and " << endl;
    cout << "press enter to continue." << endl;
    cout << "All rotors will spin for some time." << endl;
    char k;
    cin >> k; 
    for(int i = 0; i < 4; i++) {
        quadEngines[i].spinTest(spinTestMS);
    }
}

void qEngineSet::updateLEDMode(int newMode) {
    for(int i = 0; i < numEngines; i++) {
        quadEngines[i].updateLEDMode(newMode);
    }
}

int qEngineSet::terminate() {
    float qRet = 0.0;
    for(int i = 0; i < numEngines; i++) {
        qRet+=quadEngines[i].stop();
    }  
    gpioTerminate();
    if(qRet>0) {
        return(1);    
    }
    return(0);
}

int* qEngineSet::getEngineVals() {
    int eVals[numEngines];
    for(int i = 0; i < numEngines; i++) {
        eVals[i] = quadEngines[i].getPower();
    }    
}

void qEngineSet::handleKey(char k, bool shiftMode) {
    // TODO: k = tolower(k) 
    // shiftMode == true implies shift is down
    // shiftmode == false implies shift is up
    int powerDelta = 100;
    if(k=='q') {
        for(int i = 0; i < numEngines; i++) {
            quadEngines[i].stop();
        }
    }
    else if(shiftMode==true) {
        // we increase power
        if(k=='i') {
            quadEngines[0].incPower(powerDelta);
        }
        else if(k=='j') {
            quadEngines[1].incPower(powerDelta);
        }
        else if(k=='m') {
            quadEngines[2].incPower(powerDelta);
        }
        else if(k=='l') {
            quadEngines[3].incPower(powerDelta);
        }
        // all engines
        /* is it bad to assume this will happen so quickly that 
         * instability won't be generated by the latency?
         */
        else if(k=='k') {
            for(int i = 0; i < numEngines; i++) {
                quadEngines[i].incPower(powerDelta);
            }
        }
    } 
    else if(shiftMode==false) {
        // we decrease power
        if(k=='i') {
            quadEngines[0].decPower(powerDelta);
        }
        else if(k=='j') {
            quadEngines[1].decPower(powerDelta);
        }
        else if(k=='m') {
            quadEngines[2].decPower(powerDelta);
        }
        else if(k=='l') {
            quadEngines[3].decPower(powerDelta);
        }
        // all engines
        // same query: latency an issue?
        else if(k=='k') {
            for(int i = 0; i < numEngines; i++) {
                quadEngines[i].decPower(powerDelta);
            }
        }
    }

}

int qEngineSet::stabilize(sensorData inSensorData) {
    /*
     * Stablize the quadcopter.   
    this is something of an algorithmic mystery to me.  
    what is the purpose of stabilization?  we will aim to 
    keep the pitch and roll angles to a minimum.
    
    yaw, we should also try to minimize that insofar as it the 
    quadcopter should not spin around in circles

    So we hazard a guess that we need to maintain the lowest 
    variance possible for blade energy to keep the quadcopter from 
    constantly flying upwards.

    Second, we look at the pitch/roll angles as feedback that we
    will use to identify how proportional a response the motors
    need to make.

    Finally, we need to compare the pairs of CW and CCW rotating
    blades to ensure that one average isn't overpowering
    the other (i.e. the copter doesn't spin on axis in circles)

     */
    array<float,3> inAngles = inSensorData.getAxisAngles();
    float pitch = inAngles[1]; // Y
    float roll = inAngles[0];  // X
    float yaw = inAngles[2];   // Z

    int CCW[2] = {0,3};
    int CW[2] = {1,2};

    float CCWPower = (quadEngines[CCW[0]].getPower()
          + quadEngines[CCW[1]].getPower()) / 2.0;
    float CWPower = (quadEngines[CW[0]].getPower() 
          + quadEngines[CW[1]].getPower()) / 2.0; 
    float vPower = abs(CCWPower - CWPower);

}
